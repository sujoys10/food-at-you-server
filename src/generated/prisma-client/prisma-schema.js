module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateItem {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregateOrderBag {
  count: Int!
}

type AggregateOrderedItem {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateVendor {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Item {
  id: ID!
  name: String!
  category: String!
  type: ItemType!
  url: String
  description: String!
  price: Int!
  is_available: Boolean!
  rating: Int
  vendor: Vendor!
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  id: ID
  name: String!
  category: String!
  type: ItemType!
  url: String
  description: String!
  price: Int!
  is_available: Boolean!
  rating: Int
  vendor: VendorCreateOneWithoutItemsInput!
}

input ItemCreateManyWithoutVendorInput {
  create: [ItemCreateWithoutVendorInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateOneInput {
  create: ItemCreateInput
  connect: ItemWhereUniqueInput
}

input ItemCreateWithoutVendorInput {
  id: ID
  name: String!
  category: String!
  type: ItemType!
  url: String
  description: String!
  price: Int!
  is_available: Boolean!
  rating: Int
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  category_ASC
  category_DESC
  type_ASC
  type_DESC
  url_ASC
  url_DESC
  description_ASC
  description_DESC
  price_ASC
  price_DESC
  is_available_ASC
  is_available_DESC
  rating_ASC
  rating_DESC
}

type ItemPreviousValues {
  id: ID!
  name: String!
  category: String!
  type: ItemType!
  url: String
  description: String!
  price: Int!
  is_available: Boolean!
  rating: Int
}

input ItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  type: ItemType
  type_not: ItemType
  type_in: [ItemType!]
  type_not_in: [ItemType!]
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  is_available: Boolean
  is_available_not: Boolean
  rating: Int
  rating_not: Int
  rating_in: [Int!]
  rating_not_in: [Int!]
  rating_lt: Int
  rating_lte: Int
  rating_gt: Int
  rating_gte: Int
  AND: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

enum ItemType {
  BREAKFAST
  LUNCH
  SNACKS
  DINNER
}

input ItemUpdateDataInput {
  name: String
  category: String
  type: ItemType
  url: String
  description: String
  price: Int
  is_available: Boolean
  rating: Int
  vendor: VendorUpdateOneRequiredWithoutItemsInput
}

input ItemUpdateInput {
  name: String
  category: String
  type: ItemType
  url: String
  description: String
  price: Int
  is_available: Boolean
  rating: Int
  vendor: VendorUpdateOneRequiredWithoutItemsInput
}

input ItemUpdateManyDataInput {
  name: String
  category: String
  type: ItemType
  url: String
  description: String
  price: Int
  is_available: Boolean
  rating: Int
}

input ItemUpdateManyMutationInput {
  name: String
  category: String
  type: ItemType
  url: String
  description: String
  price: Int
  is_available: Boolean
  rating: Int
}

input ItemUpdateManyWithoutVendorInput {
  create: [ItemCreateWithoutVendorInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutVendorInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutVendorInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput!
  data: ItemUpdateManyDataInput!
}

input ItemUpdateOneRequiredInput {
  create: ItemCreateInput
  update: ItemUpdateDataInput
  upsert: ItemUpsertNestedInput
  connect: ItemWhereUniqueInput
}

input ItemUpdateWithoutVendorDataInput {
  name: String
  category: String
  type: ItemType
  url: String
  description: String
  price: Int
  is_available: Boolean
  rating: Int
}

input ItemUpdateWithWhereUniqueWithoutVendorInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutVendorDataInput!
}

input ItemUpsertNestedInput {
  update: ItemUpdateDataInput!
  create: ItemCreateInput!
}

input ItemUpsertWithWhereUniqueWithoutVendorInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutVendorDataInput!
  create: ItemCreateWithoutVendorInput!
}

input ItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  type: ItemType
  type_not: ItemType
  type_in: [ItemType!]
  type_not_in: [ItemType!]
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  is_available: Boolean
  is_available_not: Boolean
  rating: Int
  rating_not: Int
  rating_in: [Int!]
  rating_not_in: [Int!]
  rating_lt: Int
  rating_lte: Int
  rating_gt: Int
  rating_gte: Int
  vendor: VendorWhereInput
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateManyOrders(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createOrderBag(data: OrderBagCreateInput!): OrderBag!
  updateOrderBag(data: OrderBagUpdateInput!, where: OrderBagWhereUniqueInput!): OrderBag
  updateManyOrderBags(data: OrderBagUpdateManyMutationInput!, where: OrderBagWhereInput): BatchPayload!
  upsertOrderBag(where: OrderBagWhereUniqueInput!, create: OrderBagCreateInput!, update: OrderBagUpdateInput!): OrderBag!
  deleteOrderBag(where: OrderBagWhereUniqueInput!): OrderBag
  deleteManyOrderBags(where: OrderBagWhereInput): BatchPayload!
  createOrderedItem(data: OrderedItemCreateInput!): OrderedItem!
  updateOrderedItem(data: OrderedItemUpdateInput!, where: OrderedItemWhereUniqueInput!): OrderedItem
  updateManyOrderedItems(data: OrderedItemUpdateManyMutationInput!, where: OrderedItemWhereInput): BatchPayload!
  upsertOrderedItem(where: OrderedItemWhereUniqueInput!, create: OrderedItemCreateInput!, update: OrderedItemUpdateInput!): OrderedItem!
  deleteOrderedItem(where: OrderedItemWhereUniqueInput!): OrderedItem
  deleteManyOrderedItems(where: OrderedItemWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createVendor(data: VendorCreateInput!): Vendor!
  updateVendor(data: VendorUpdateInput!, where: VendorWhereUniqueInput!): Vendor
  updateManyVendors(data: VendorUpdateManyMutationInput!, where: VendorWhereInput): BatchPayload!
  upsertVendor(where: VendorWhereUniqueInput!, create: VendorCreateInput!, update: VendorUpdateInput!): Vendor!
  deleteVendor(where: VendorWhereUniqueInput!): Vendor
  deleteManyVendors(where: VendorWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Order {
  id: ID!
  order_bags(where: OrderBagWhereInput, orderBy: OrderBagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderBag!]
  total: Int!
  customer: User!
  vendor: Vendor!
  order_date: DateTime!
  delivery_address: String!
  shipper: String
  payment_details: String
  status: OrderStatus
}

type OrderBag {
  id: ID!
  type: ItemType!
  order: Order
  status: OrderStatus!
  items(where: OrderedItemWhereInput, orderBy: OrderedItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderedItem!]
  delivery_date: DateTime!
}

type OrderBagConnection {
  pageInfo: PageInfo!
  edges: [OrderBagEdge]!
  aggregate: AggregateOrderBag!
}

input OrderBagCreateInput {
  id: ID
  type: ItemType!
  order: OrderCreateOneWithoutOrder_bagsInput
  status: OrderStatus
  items: OrderedItemCreateManyWithoutOrder_bagInput
  delivery_date: DateTime!
}

input OrderBagCreateManyWithoutOrderInput {
  create: [OrderBagCreateWithoutOrderInput!]
  connect: [OrderBagWhereUniqueInput!]
}

input OrderBagCreateOneWithoutItemsInput {
  create: OrderBagCreateWithoutItemsInput
  connect: OrderBagWhereUniqueInput
}

input OrderBagCreateWithoutItemsInput {
  id: ID
  type: ItemType!
  order: OrderCreateOneWithoutOrder_bagsInput
  status: OrderStatus
  delivery_date: DateTime!
}

input OrderBagCreateWithoutOrderInput {
  id: ID
  type: ItemType!
  status: OrderStatus
  items: OrderedItemCreateManyWithoutOrder_bagInput
  delivery_date: DateTime!
}

type OrderBagEdge {
  node: OrderBag!
  cursor: String!
}

enum OrderBagOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  status_ASC
  status_DESC
  delivery_date_ASC
  delivery_date_DESC
}

type OrderBagPreviousValues {
  id: ID!
  type: ItemType!
  status: OrderStatus!
  delivery_date: DateTime!
}

input OrderBagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: ItemType
  type_not: ItemType
  type_in: [ItemType!]
  type_not_in: [ItemType!]
  status: OrderStatus
  status_not: OrderStatus
  status_in: [OrderStatus!]
  status_not_in: [OrderStatus!]
  delivery_date: DateTime
  delivery_date_not: DateTime
  delivery_date_in: [DateTime!]
  delivery_date_not_in: [DateTime!]
  delivery_date_lt: DateTime
  delivery_date_lte: DateTime
  delivery_date_gt: DateTime
  delivery_date_gte: DateTime
  AND: [OrderBagScalarWhereInput!]
  OR: [OrderBagScalarWhereInput!]
  NOT: [OrderBagScalarWhereInput!]
}

type OrderBagSubscriptionPayload {
  mutation: MutationType!
  node: OrderBag
  updatedFields: [String!]
  previousValues: OrderBagPreviousValues
}

input OrderBagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderBagWhereInput
  AND: [OrderBagSubscriptionWhereInput!]
  OR: [OrderBagSubscriptionWhereInput!]
  NOT: [OrderBagSubscriptionWhereInput!]
}

input OrderBagUpdateInput {
  type: ItemType
  order: OrderUpdateOneWithoutOrder_bagsInput
  status: OrderStatus
  items: OrderedItemUpdateManyWithoutOrder_bagInput
  delivery_date: DateTime
}

input OrderBagUpdateManyDataInput {
  type: ItemType
  status: OrderStatus
  delivery_date: DateTime
}

input OrderBagUpdateManyMutationInput {
  type: ItemType
  status: OrderStatus
  delivery_date: DateTime
}

input OrderBagUpdateManyWithoutOrderInput {
  create: [OrderBagCreateWithoutOrderInput!]
  delete: [OrderBagWhereUniqueInput!]
  connect: [OrderBagWhereUniqueInput!]
  set: [OrderBagWhereUniqueInput!]
  disconnect: [OrderBagWhereUniqueInput!]
  update: [OrderBagUpdateWithWhereUniqueWithoutOrderInput!]
  upsert: [OrderBagUpsertWithWhereUniqueWithoutOrderInput!]
  deleteMany: [OrderBagScalarWhereInput!]
  updateMany: [OrderBagUpdateManyWithWhereNestedInput!]
}

input OrderBagUpdateManyWithWhereNestedInput {
  where: OrderBagScalarWhereInput!
  data: OrderBagUpdateManyDataInput!
}

input OrderBagUpdateOneWithoutItemsInput {
  create: OrderBagCreateWithoutItemsInput
  update: OrderBagUpdateWithoutItemsDataInput
  upsert: OrderBagUpsertWithoutItemsInput
  delete: Boolean
  disconnect: Boolean
  connect: OrderBagWhereUniqueInput
}

input OrderBagUpdateWithoutItemsDataInput {
  type: ItemType
  order: OrderUpdateOneWithoutOrder_bagsInput
  status: OrderStatus
  delivery_date: DateTime
}

input OrderBagUpdateWithoutOrderDataInput {
  type: ItemType
  status: OrderStatus
  items: OrderedItemUpdateManyWithoutOrder_bagInput
  delivery_date: DateTime
}

input OrderBagUpdateWithWhereUniqueWithoutOrderInput {
  where: OrderBagWhereUniqueInput!
  data: OrderBagUpdateWithoutOrderDataInput!
}

input OrderBagUpsertWithoutItemsInput {
  update: OrderBagUpdateWithoutItemsDataInput!
  create: OrderBagCreateWithoutItemsInput!
}

input OrderBagUpsertWithWhereUniqueWithoutOrderInput {
  where: OrderBagWhereUniqueInput!
  update: OrderBagUpdateWithoutOrderDataInput!
  create: OrderBagCreateWithoutOrderInput!
}

input OrderBagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: ItemType
  type_not: ItemType
  type_in: [ItemType!]
  type_not_in: [ItemType!]
  order: OrderWhereInput
  status: OrderStatus
  status_not: OrderStatus
  status_in: [OrderStatus!]
  status_not_in: [OrderStatus!]
  items_every: OrderedItemWhereInput
  items_some: OrderedItemWhereInput
  items_none: OrderedItemWhereInput
  delivery_date: DateTime
  delivery_date_not: DateTime
  delivery_date_in: [DateTime!]
  delivery_date_not_in: [DateTime!]
  delivery_date_lt: DateTime
  delivery_date_lte: DateTime
  delivery_date_gt: DateTime
  delivery_date_gte: DateTime
  AND: [OrderBagWhereInput!]
  OR: [OrderBagWhereInput!]
  NOT: [OrderBagWhereInput!]
}

input OrderBagWhereUniqueInput {
  id: ID
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  id: ID
  order_bags: OrderBagCreateManyWithoutOrderInput
  total: Int!
  customer: UserCreateOneWithoutOrdersInput!
  vendor: VendorCreateOneWithoutOrdersInput!
  order_date: DateTime!
  delivery_address: String!
  shipper: String
  payment_details: String
  status: OrderStatus
}

input OrderCreateManyWithoutCustomerInput {
  create: [OrderCreateWithoutCustomerInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateManyWithoutVendorInput {
  create: [OrderCreateWithoutVendorInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateOneWithoutOrder_bagsInput {
  create: OrderCreateWithoutOrder_bagsInput
  connect: OrderWhereUniqueInput
}

input OrderCreateWithoutCustomerInput {
  id: ID
  order_bags: OrderBagCreateManyWithoutOrderInput
  total: Int!
  vendor: VendorCreateOneWithoutOrdersInput!
  order_date: DateTime!
  delivery_address: String!
  shipper: String
  payment_details: String
  status: OrderStatus
}

input OrderCreateWithoutOrder_bagsInput {
  id: ID
  total: Int!
  customer: UserCreateOneWithoutOrdersInput!
  vendor: VendorCreateOneWithoutOrdersInput!
  order_date: DateTime!
  delivery_address: String!
  shipper: String
  payment_details: String
  status: OrderStatus
}

input OrderCreateWithoutVendorInput {
  id: ID
  order_bags: OrderBagCreateManyWithoutOrderInput
  total: Int!
  customer: UserCreateOneWithoutOrdersInput!
  order_date: DateTime!
  delivery_address: String!
  shipper: String
  payment_details: String
  status: OrderStatus
}

type OrderEdge {
  node: Order!
  cursor: String!
}

type OrderedItem {
  id: ID!
  item: Item!
  type: ItemType!
  quantity: Int!
  order_bag: OrderBag
  delivery_date: DateTime
  status: OrderStatus
}

type OrderedItemConnection {
  pageInfo: PageInfo!
  edges: [OrderedItemEdge]!
  aggregate: AggregateOrderedItem!
}

input OrderedItemCreateInput {
  id: ID
  item: ItemCreateOneInput!
  type: ItemType!
  quantity: Int!
  order_bag: OrderBagCreateOneWithoutItemsInput
  delivery_date: DateTime
  status: OrderStatus
}

input OrderedItemCreateManyWithoutOrder_bagInput {
  create: [OrderedItemCreateWithoutOrder_bagInput!]
  connect: [OrderedItemWhereUniqueInput!]
}

input OrderedItemCreateWithoutOrder_bagInput {
  id: ID
  item: ItemCreateOneInput!
  type: ItemType!
  quantity: Int!
  delivery_date: DateTime
  status: OrderStatus
}

type OrderedItemEdge {
  node: OrderedItem!
  cursor: String!
}

enum OrderedItemOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  quantity_ASC
  quantity_DESC
  delivery_date_ASC
  delivery_date_DESC
  status_ASC
  status_DESC
}

type OrderedItemPreviousValues {
  id: ID!
  type: ItemType!
  quantity: Int!
  delivery_date: DateTime
  status: OrderStatus
}

input OrderedItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: ItemType
  type_not: ItemType
  type_in: [ItemType!]
  type_not_in: [ItemType!]
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  delivery_date: DateTime
  delivery_date_not: DateTime
  delivery_date_in: [DateTime!]
  delivery_date_not_in: [DateTime!]
  delivery_date_lt: DateTime
  delivery_date_lte: DateTime
  delivery_date_gt: DateTime
  delivery_date_gte: DateTime
  status: OrderStatus
  status_not: OrderStatus
  status_in: [OrderStatus!]
  status_not_in: [OrderStatus!]
  AND: [OrderedItemScalarWhereInput!]
  OR: [OrderedItemScalarWhereInput!]
  NOT: [OrderedItemScalarWhereInput!]
}

type OrderedItemSubscriptionPayload {
  mutation: MutationType!
  node: OrderedItem
  updatedFields: [String!]
  previousValues: OrderedItemPreviousValues
}

input OrderedItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderedItemWhereInput
  AND: [OrderedItemSubscriptionWhereInput!]
  OR: [OrderedItemSubscriptionWhereInput!]
  NOT: [OrderedItemSubscriptionWhereInput!]
}

input OrderedItemUpdateInput {
  item: ItemUpdateOneRequiredInput
  type: ItemType
  quantity: Int
  order_bag: OrderBagUpdateOneWithoutItemsInput
  delivery_date: DateTime
  status: OrderStatus
}

input OrderedItemUpdateManyDataInput {
  type: ItemType
  quantity: Int
  delivery_date: DateTime
  status: OrderStatus
}

input OrderedItemUpdateManyMutationInput {
  type: ItemType
  quantity: Int
  delivery_date: DateTime
  status: OrderStatus
}

input OrderedItemUpdateManyWithoutOrder_bagInput {
  create: [OrderedItemCreateWithoutOrder_bagInput!]
  delete: [OrderedItemWhereUniqueInput!]
  connect: [OrderedItemWhereUniqueInput!]
  set: [OrderedItemWhereUniqueInput!]
  disconnect: [OrderedItemWhereUniqueInput!]
  update: [OrderedItemUpdateWithWhereUniqueWithoutOrder_bagInput!]
  upsert: [OrderedItemUpsertWithWhereUniqueWithoutOrder_bagInput!]
  deleteMany: [OrderedItemScalarWhereInput!]
  updateMany: [OrderedItemUpdateManyWithWhereNestedInput!]
}

input OrderedItemUpdateManyWithWhereNestedInput {
  where: OrderedItemScalarWhereInput!
  data: OrderedItemUpdateManyDataInput!
}

input OrderedItemUpdateWithoutOrder_bagDataInput {
  item: ItemUpdateOneRequiredInput
  type: ItemType
  quantity: Int
  delivery_date: DateTime
  status: OrderStatus
}

input OrderedItemUpdateWithWhereUniqueWithoutOrder_bagInput {
  where: OrderedItemWhereUniqueInput!
  data: OrderedItemUpdateWithoutOrder_bagDataInput!
}

input OrderedItemUpsertWithWhereUniqueWithoutOrder_bagInput {
  where: OrderedItemWhereUniqueInput!
  update: OrderedItemUpdateWithoutOrder_bagDataInput!
  create: OrderedItemCreateWithoutOrder_bagInput!
}

input OrderedItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  item: ItemWhereInput
  type: ItemType
  type_not: ItemType
  type_in: [ItemType!]
  type_not_in: [ItemType!]
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  order_bag: OrderBagWhereInput
  delivery_date: DateTime
  delivery_date_not: DateTime
  delivery_date_in: [DateTime!]
  delivery_date_not_in: [DateTime!]
  delivery_date_lt: DateTime
  delivery_date_lte: DateTime
  delivery_date_gt: DateTime
  delivery_date_gte: DateTime
  status: OrderStatus
  status_not: OrderStatus
  status_in: [OrderStatus!]
  status_not_in: [OrderStatus!]
  AND: [OrderedItemWhereInput!]
  OR: [OrderedItemWhereInput!]
  NOT: [OrderedItemWhereInput!]
}

input OrderedItemWhereUniqueInput {
  id: ID
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
  total_ASC
  total_DESC
  order_date_ASC
  order_date_DESC
  delivery_address_ASC
  delivery_address_DESC
  shipper_ASC
  shipper_DESC
  payment_details_ASC
  payment_details_DESC
  status_ASC
  status_DESC
}

type OrderPreviousValues {
  id: ID!
  total: Int!
  order_date: DateTime!
  delivery_address: String!
  shipper: String
  payment_details: String
  status: OrderStatus
}

input OrderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  total: Int
  total_not: Int
  total_in: [Int!]
  total_not_in: [Int!]
  total_lt: Int
  total_lte: Int
  total_gt: Int
  total_gte: Int
  order_date: DateTime
  order_date_not: DateTime
  order_date_in: [DateTime!]
  order_date_not_in: [DateTime!]
  order_date_lt: DateTime
  order_date_lte: DateTime
  order_date_gt: DateTime
  order_date_gte: DateTime
  delivery_address: String
  delivery_address_not: String
  delivery_address_in: [String!]
  delivery_address_not_in: [String!]
  delivery_address_lt: String
  delivery_address_lte: String
  delivery_address_gt: String
  delivery_address_gte: String
  delivery_address_contains: String
  delivery_address_not_contains: String
  delivery_address_starts_with: String
  delivery_address_not_starts_with: String
  delivery_address_ends_with: String
  delivery_address_not_ends_with: String
  shipper: String
  shipper_not: String
  shipper_in: [String!]
  shipper_not_in: [String!]
  shipper_lt: String
  shipper_lte: String
  shipper_gt: String
  shipper_gte: String
  shipper_contains: String
  shipper_not_contains: String
  shipper_starts_with: String
  shipper_not_starts_with: String
  shipper_ends_with: String
  shipper_not_ends_with: String
  payment_details: String
  payment_details_not: String
  payment_details_in: [String!]
  payment_details_not_in: [String!]
  payment_details_lt: String
  payment_details_lte: String
  payment_details_gt: String
  payment_details_gte: String
  payment_details_contains: String
  payment_details_not_contains: String
  payment_details_starts_with: String
  payment_details_not_starts_with: String
  payment_details_ends_with: String
  payment_details_not_ends_with: String
  status: OrderStatus
  status_not: OrderStatus
  status_in: [OrderStatus!]
  status_not_in: [OrderStatus!]
  AND: [OrderScalarWhereInput!]
  OR: [OrderScalarWhereInput!]
  NOT: [OrderScalarWhereInput!]
}

enum OrderStatus {
  PLACED
  ACCEPTED
  CANCELLED
  PROCESSING
  DELIVERED
  RECEIVED
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderUpdateInput {
  order_bags: OrderBagUpdateManyWithoutOrderInput
  total: Int
  customer: UserUpdateOneRequiredWithoutOrdersInput
  vendor: VendorUpdateOneRequiredWithoutOrdersInput
  order_date: DateTime
  delivery_address: String
  shipper: String
  payment_details: String
  status: OrderStatus
}

input OrderUpdateManyDataInput {
  total: Int
  order_date: DateTime
  delivery_address: String
  shipper: String
  payment_details: String
  status: OrderStatus
}

input OrderUpdateManyMutationInput {
  total: Int
  order_date: DateTime
  delivery_address: String
  shipper: String
  payment_details: String
  status: OrderStatus
}

input OrderUpdateManyWithoutCustomerInput {
  create: [OrderCreateWithoutCustomerInput!]
  delete: [OrderWhereUniqueInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutCustomerInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutCustomerInput!]
  deleteMany: [OrderScalarWhereInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
}

input OrderUpdateManyWithoutVendorInput {
  create: [OrderCreateWithoutVendorInput!]
  delete: [OrderWhereUniqueInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutVendorInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutVendorInput!]
  deleteMany: [OrderScalarWhereInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
}

input OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput!
  data: OrderUpdateManyDataInput!
}

input OrderUpdateOneWithoutOrder_bagsInput {
  create: OrderCreateWithoutOrder_bagsInput
  update: OrderUpdateWithoutOrder_bagsDataInput
  upsert: OrderUpsertWithoutOrder_bagsInput
  delete: Boolean
  disconnect: Boolean
  connect: OrderWhereUniqueInput
}

input OrderUpdateWithoutCustomerDataInput {
  order_bags: OrderBagUpdateManyWithoutOrderInput
  total: Int
  vendor: VendorUpdateOneRequiredWithoutOrdersInput
  order_date: DateTime
  delivery_address: String
  shipper: String
  payment_details: String
  status: OrderStatus
}

input OrderUpdateWithoutOrder_bagsDataInput {
  total: Int
  customer: UserUpdateOneRequiredWithoutOrdersInput
  vendor: VendorUpdateOneRequiredWithoutOrdersInput
  order_date: DateTime
  delivery_address: String
  shipper: String
  payment_details: String
  status: OrderStatus
}

input OrderUpdateWithoutVendorDataInput {
  order_bags: OrderBagUpdateManyWithoutOrderInput
  total: Int
  customer: UserUpdateOneRequiredWithoutOrdersInput
  order_date: DateTime
  delivery_address: String
  shipper: String
  payment_details: String
  status: OrderStatus
}

input OrderUpdateWithWhereUniqueWithoutCustomerInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateWithoutCustomerDataInput!
}

input OrderUpdateWithWhereUniqueWithoutVendorInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateWithoutVendorDataInput!
}

input OrderUpsertWithoutOrder_bagsInput {
  update: OrderUpdateWithoutOrder_bagsDataInput!
  create: OrderCreateWithoutOrder_bagsInput!
}

input OrderUpsertWithWhereUniqueWithoutCustomerInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateWithoutCustomerDataInput!
  create: OrderCreateWithoutCustomerInput!
}

input OrderUpsertWithWhereUniqueWithoutVendorInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateWithoutVendorDataInput!
  create: OrderCreateWithoutVendorInput!
}

input OrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  order_bags_every: OrderBagWhereInput
  order_bags_some: OrderBagWhereInput
  order_bags_none: OrderBagWhereInput
  total: Int
  total_not: Int
  total_in: [Int!]
  total_not_in: [Int!]
  total_lt: Int
  total_lte: Int
  total_gt: Int
  total_gte: Int
  customer: UserWhereInput
  vendor: VendorWhereInput
  order_date: DateTime
  order_date_not: DateTime
  order_date_in: [DateTime!]
  order_date_not_in: [DateTime!]
  order_date_lt: DateTime
  order_date_lte: DateTime
  order_date_gt: DateTime
  order_date_gte: DateTime
  delivery_address: String
  delivery_address_not: String
  delivery_address_in: [String!]
  delivery_address_not_in: [String!]
  delivery_address_lt: String
  delivery_address_lte: String
  delivery_address_gt: String
  delivery_address_gte: String
  delivery_address_contains: String
  delivery_address_not_contains: String
  delivery_address_starts_with: String
  delivery_address_not_starts_with: String
  delivery_address_ends_with: String
  delivery_address_not_ends_with: String
  shipper: String
  shipper_not: String
  shipper_in: [String!]
  shipper_not_in: [String!]
  shipper_lt: String
  shipper_lte: String
  shipper_gt: String
  shipper_gte: String
  shipper_contains: String
  shipper_not_contains: String
  shipper_starts_with: String
  shipper_not_starts_with: String
  shipper_ends_with: String
  shipper_not_ends_with: String
  payment_details: String
  payment_details_not: String
  payment_details_in: [String!]
  payment_details_not_in: [String!]
  payment_details_lt: String
  payment_details_lte: String
  payment_details_gt: String
  payment_details_gte: String
  payment_details_contains: String
  payment_details_not_contains: String
  payment_details_starts_with: String
  payment_details_not_starts_with: String
  payment_details_ends_with: String
  payment_details_not_ends_with: String
  status: OrderStatus
  status_not: OrderStatus
  status_in: [OrderStatus!]
  status_not_in: [OrderStatus!]
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  orderBag(where: OrderBagWhereUniqueInput!): OrderBag
  orderBags(where: OrderBagWhereInput, orderBy: OrderBagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderBag]!
  orderBagsConnection(where: OrderBagWhereInput, orderBy: OrderBagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderBagConnection!
  orderedItem(where: OrderedItemWhereUniqueInput!): OrderedItem
  orderedItems(where: OrderedItemWhereInput, orderBy: OrderedItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderedItem]!
  orderedItemsConnection(where: OrderedItemWhereInput, orderBy: OrderedItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderedItemConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  vendor(where: VendorWhereUniqueInput!): Vendor
  vendors(where: VendorWhereInput, orderBy: VendorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vendor]!
  vendorsConnection(where: VendorWhereInput, orderBy: VendorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VendorConnection!
  node(id: ID!): Node
}

type Subscription {
  item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  orderBag(where: OrderBagSubscriptionWhereInput): OrderBagSubscriptionPayload
  orderedItem(where: OrderedItemSubscriptionWhereInput): OrderedItemSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  vendor(where: VendorSubscriptionWhereInput): VendorSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  email: String!
  password: String!
  address: String
  phone: Int
  created_at: DateTime!
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  email: String!
  password: String!
  address: String
  phone: Int
  orders: OrderCreateManyWithoutCustomerInput
}

input UserCreateOneWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutOrdersInput {
  id: ID
  name: String!
  email: String!
  password: String!
  address: String
  phone: Int
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  address_ASC
  address_DESC
  phone_ASC
  phone_DESC
  created_at_ASC
  created_at_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  password: String!
  address: String
  phone: Int
  created_at: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  address: String
  phone: Int
  orders: OrderUpdateManyWithoutCustomerInput
}

input UserUpdateManyMutationInput {
  name: String
  email: String
  password: String
  address: String
  phone: Int
}

input UserUpdateOneRequiredWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput
  update: UserUpdateWithoutOrdersDataInput
  upsert: UserUpsertWithoutOrdersInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutOrdersDataInput {
  name: String
  email: String
  password: String
  address: String
  phone: Int
}

input UserUpsertWithoutOrdersInput {
  update: UserUpdateWithoutOrdersDataInput!
  create: UserCreateWithoutOrdersInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  phone: Int
  phone_not: Int
  phone_in: [Int!]
  phone_not_in: [Int!]
  phone_lt: Int
  phone_lte: Int
  phone_gt: Int
  phone_gte: Int
  created_at: DateTime
  created_at_not: DateTime
  created_at_in: [DateTime!]
  created_at_not_in: [DateTime!]
  created_at_lt: DateTime
  created_at_lte: DateTime
  created_at_gt: DateTime
  created_at_gte: DateTime
  orders_every: OrderWhereInput
  orders_some: OrderWhereInput
  orders_none: OrderWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
  password: String
  phone: Int
}

type Vendor {
  id: ID!
  name: String!
  email: String!
  password: String!
  address: String
  phone: Int
  created_at: DateTime!
  payment_details: String
  rating: Int
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
}

type VendorConnection {
  pageInfo: PageInfo!
  edges: [VendorEdge]!
  aggregate: AggregateVendor!
}

input VendorCreateInput {
  id: ID
  name: String!
  email: String!
  password: String!
  address: String
  phone: Int
  payment_details: String
  rating: Int
  items: ItemCreateManyWithoutVendorInput
  orders: OrderCreateManyWithoutVendorInput
}

input VendorCreateOneWithoutItemsInput {
  create: VendorCreateWithoutItemsInput
  connect: VendorWhereUniqueInput
}

input VendorCreateOneWithoutOrdersInput {
  create: VendorCreateWithoutOrdersInput
  connect: VendorWhereUniqueInput
}

input VendorCreateWithoutItemsInput {
  id: ID
  name: String!
  email: String!
  password: String!
  address: String
  phone: Int
  payment_details: String
  rating: Int
  orders: OrderCreateManyWithoutVendorInput
}

input VendorCreateWithoutOrdersInput {
  id: ID
  name: String!
  email: String!
  password: String!
  address: String
  phone: Int
  payment_details: String
  rating: Int
  items: ItemCreateManyWithoutVendorInput
}

type VendorEdge {
  node: Vendor!
  cursor: String!
}

enum VendorOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  address_ASC
  address_DESC
  phone_ASC
  phone_DESC
  created_at_ASC
  created_at_DESC
  payment_details_ASC
  payment_details_DESC
  rating_ASC
  rating_DESC
}

type VendorPreviousValues {
  id: ID!
  name: String!
  email: String!
  password: String!
  address: String
  phone: Int
  created_at: DateTime!
  payment_details: String
  rating: Int
}

type VendorSubscriptionPayload {
  mutation: MutationType!
  node: Vendor
  updatedFields: [String!]
  previousValues: VendorPreviousValues
}

input VendorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VendorWhereInput
  AND: [VendorSubscriptionWhereInput!]
  OR: [VendorSubscriptionWhereInput!]
  NOT: [VendorSubscriptionWhereInput!]
}

input VendorUpdateInput {
  name: String
  email: String
  password: String
  address: String
  phone: Int
  payment_details: String
  rating: Int
  items: ItemUpdateManyWithoutVendorInput
  orders: OrderUpdateManyWithoutVendorInput
}

input VendorUpdateManyMutationInput {
  name: String
  email: String
  password: String
  address: String
  phone: Int
  payment_details: String
  rating: Int
}

input VendorUpdateOneRequiredWithoutItemsInput {
  create: VendorCreateWithoutItemsInput
  update: VendorUpdateWithoutItemsDataInput
  upsert: VendorUpsertWithoutItemsInput
  connect: VendorWhereUniqueInput
}

input VendorUpdateOneRequiredWithoutOrdersInput {
  create: VendorCreateWithoutOrdersInput
  update: VendorUpdateWithoutOrdersDataInput
  upsert: VendorUpsertWithoutOrdersInput
  connect: VendorWhereUniqueInput
}

input VendorUpdateWithoutItemsDataInput {
  name: String
  email: String
  password: String
  address: String
  phone: Int
  payment_details: String
  rating: Int
  orders: OrderUpdateManyWithoutVendorInput
}

input VendorUpdateWithoutOrdersDataInput {
  name: String
  email: String
  password: String
  address: String
  phone: Int
  payment_details: String
  rating: Int
  items: ItemUpdateManyWithoutVendorInput
}

input VendorUpsertWithoutItemsInput {
  update: VendorUpdateWithoutItemsDataInput!
  create: VendorCreateWithoutItemsInput!
}

input VendorUpsertWithoutOrdersInput {
  update: VendorUpdateWithoutOrdersDataInput!
  create: VendorCreateWithoutOrdersInput!
}

input VendorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  phone: Int
  phone_not: Int
  phone_in: [Int!]
  phone_not_in: [Int!]
  phone_lt: Int
  phone_lte: Int
  phone_gt: Int
  phone_gte: Int
  created_at: DateTime
  created_at_not: DateTime
  created_at_in: [DateTime!]
  created_at_not_in: [DateTime!]
  created_at_lt: DateTime
  created_at_lte: DateTime
  created_at_gt: DateTime
  created_at_gte: DateTime
  payment_details: String
  payment_details_not: String
  payment_details_in: [String!]
  payment_details_not_in: [String!]
  payment_details_lt: String
  payment_details_lte: String
  payment_details_gt: String
  payment_details_gte: String
  payment_details_contains: String
  payment_details_not_contains: String
  payment_details_starts_with: String
  payment_details_not_starts_with: String
  payment_details_ends_with: String
  payment_details_not_ends_with: String
  rating: Int
  rating_not: Int
  rating_in: [Int!]
  rating_not_in: [Int!]
  rating_lt: Int
  rating_lte: Int
  rating_gt: Int
  rating_gte: Int
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  orders_every: OrderWhereInput
  orders_some: OrderWhereInput
  orders_none: OrderWhereInput
  AND: [VendorWhereInput!]
  OR: [VendorWhereInput!]
  NOT: [VendorWhereInput!]
}

input VendorWhereUniqueInput {
  id: ID
  email: String
  password: String
  phone: Int
}
`
      }
    